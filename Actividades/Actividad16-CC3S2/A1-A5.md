
## A1. Monorepositorio vs. repositorios múltiples

Un monorepo centraliza todo el IaC —módulos, entornos y pipelines lo que inicialmente acelera el "bootstrap" porque los equipos comparten codigo, plantillas y practicas en un unico lugar: es mas facil ver ejemplos, reutilizar modulos y crear una pipeline CI/CD comun, ademas simplifica la resolucion de dependencias internas (mismo commit para codigo y su infra), reduce la friccion para cambios pequeños y evita el coste administrativo de multiples repositorios y permisos desde el arranque.

Sin embargo, cuando crece el numero de colaboradores empiezan a aparecer problemas: PRs frecuentes que compiten por los mismos archivos (conflictos y locks), revisores sobrecargados que retrasan merges, pipelines CI muy largos que consumen recursos y tiempo, y politicas de permisos demasiado amplias (gente con acceso a todo porque todo esta en un mismo repo), tambien se pierde el modelo de responsabilidades claras: un modulo con ciclos de vida independiente queda acoplado a toda la base y las releases dejan de ser deterministas.

Por eso tiene sentido extraer un modulo (como `modules/network/`) cuando su ciclo de vida, propietarios y versionado deben ser independientes, cuando se reutiliza fuera del repo original o cuando exige reglas de seguridad y despliegue distintas. Un flujo resumido de migración seria: 
1) aislar el directorio y limpiar referencias internas; 
2) filtrar historial para preservar autoria; 
3) crear el nuevo repositorio con su OWNERS y pipeline propio (lint, tests, plan/apply controlado); 
4) publicar la primera release `v1.0.0` y actualizar los consumidores para que apunten a la versión publicada (no a `main`). Este proceso garantiza trazabilidad, permisos finos y cambios controlados.

## A2. Versionado semántico y notas de versión

Publicar un modulo IaC en `v1.0.0` significa que se entrega una API estable y soportada: las variables, outputs y comportamiento son la primera version mayor publicada para consumo. Un salto a `v2.0.0` ocurre cuando hay un cambio incompatible (breaking change): se quita o renombra una variable, se altera una salida esperada o cambia el comportamiento de recursos que rompen la integración. Un incremento a `v1.1.0` (minor) corresponde a nuevas capacidades compatibles (nuevas variables opcionales, recursos añadidos que no rompen consumidores existentes). Un `v1.1.1` (patch) es una corrección de errores o ajuste no funcional.

Que otro equipo apunte a `main` es inaceptable porque `main` no es inmutable ni reproducible; carece de garantías de revisión, firma o compatibilidad. Una etiqueta firmada asegura inmutabilidad y procedencia. Una buena nota de versión debe incluir: impacto operativo, variables nuevas/eliminadas/renombradas con ejemplos, pasos de migracion manuales si los hay, riesgos y rollback, referencia a PR/issue y autor, y fecha. Esto permite a equipos planear upgrades sin romper produccion.

## A3. Seguridad en cadena de suministro

1) SBOM + verificación de proveedores: un SBOM (Software Bill of Materials) lista los proveedores, modulos y binarios usados por el modulo IaC. Verificar proveedores significa chequear checksums y firmas de binaries/providers y bloquear versiones no verificadas. Esto evita que artefactos manipulados o paquetes comprometidos entren en la pipeline.

2) SLSA / procedencia firmada: la procedencia firmada del artefacto indica exactamente de que commit, que pipeline y que actor proviene el artefacto que se publica. SLSA-style provenance hace posible reconstruir y validar que un modulo provino de un proceso de build aprobado, con controles y auditoria. Sin esta trazabilidad es imposible confiar en la integridad del modulo.

3) Politica de "solo etiquetas firmadas" para produccion: exigir firmas y rechazar modulos que no lleven etiqueta firmada asegura que solo artefactos verificables y reproducibles puedan desplegarse en produccion. Juntas, estas medidas son obligatorias en pipelines serios porque cierran vectores de ataque en la cadena de suministro, permiten validación automática en gates y facilitan auditoría y respuesta ante incidentes.

## A4. Secretos y principio de privilegio mínimo

Un error tipico de equipos junior es incluir credenciales en el repositorio (como `AWS_ACCESS_KEY` en un archivo de configuracion o en un output de Terraform) o confiar en variables locales sin rotacion. Estos secretos pueden filtrarse, quedarse en caches de CI o en historiales de commits, exponiendo infraestructura y datos.

El flujo correcto debe ser: 
1) usar un gestor centralizado de secretos (HashiCorp Vault, AWS Secrets Manager) y referenciar secretos desde IaC sin hardcodearlos; 
2) emitir credenciales efímeras con TTL corto y rotación automática; 
3) segregar alcance por entorno (dev/staging/prod) y limitar accesos mediante políticas; 
4) integrar pruebas y políticas automáticas que fallen si un output o commit parece contener un secreto (escáneres pre-commit y gates en CI que bloquean). Además, las credenciales de despliegue deben ser roles con privilegios minimos, no claves con amplio alcance.

Esto está directamente ligado al principio de privilegio mínimo en IAM: los secretos controlan quien puede hacer qué, por cuanto tiempo y en que contexto. Con rotacion, scopes por entorno y auditoria de acceso, cualquier permiso excesivo queda documentado y revocable, y las acciones quedan rastreables para cumplimiento y analisis forense.

## A5. Evidencia y auditoría

En IaC ya no vale "confia en mi" porque los cambios son automatizados y deben ser reproducibles y verificables. Un equipo debe guardar evidencia como: el SBOM con hashes de artefactos y providers, los resultados del escaneo de secretos (con timestamps), el hash del `tfstate` junto con la traza del `plan` y del `apply` (quién ejecutó y cuándo), y reportes de drift detectado y su corrección. Toda evidencia debe incluir fecha, ID de pipeline y responsable.

Retener esta evidencia con metadatos permite mapear controles tecnicos (por ejemplo: "no secrets en repo", "solo etiquetas firmadas") a controles normativos (ISO, NIST, PCI) y demostrar cumplimiento sin montar teatro. Las firmas, hashes y logs prueban que los artefactos son reproducibles, que las politicas se aplicaron y que los responsables estan bien identificados.
